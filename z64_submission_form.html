<!DOCTYPE html>
<html data-bs-theme="dark">
  <head>
    <!-- CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />

    <!-- JQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/themes/smoothness/jquery-ui.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js"></script>

    <!-- Other stuff -->
    <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.alphanum/1.0.24/jquery.alphanum.min.js"></script>
    <script src="js/typeahead.bundle.js"></script>
  </head>
  <body>
    <style>
      .loading-overlay {
        position: fixed;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        color: var(--bs-primary-text-emphasis);
        background-color: rgba(24, 24, 24, .6);
        z-index: 5600;
      }
      .loading-overlay i{
        position: absolute;
        top: 47%;
        left: 47%;
      }
      label{
        margin-bottom: .1rem;
      }
      .hint{
        padding: 0;
        margin: 0;
        margin-bottom: .25rem;
        font-size: 80%;
        opacity: .5;
      }


      .tt-hint{
        opacity: .4 !important;
      }
      .tt-menu{
        width: 100%;
        background-color: var(--bs-body-bg);
        border: var(--bs-card-border-width) solid var(--bs-primary-text-emphasis);
        padding: .5rem;
        border-radius: var(--bs-border-radius);
        margin-top: .25rem;
      }
      .tt-suggestion{
        padding: .25rem;
      }
      .tt-suggestion.tt-cursor, .tt-suggestion:hover{
        background-color: var(--bs-primary);
        color: white;
        cursor: pointer;
      }
      .twitter-typeahead {
        width: 100%;
      }

      .custom-invalid-feedback{
        width: 100%;
        margin-top: .25rem;
        font-size: .875em;
        color: var(--bs-form-invalid-color);
        display: none;
      }
    </style>

  <script type="importmap">
  {
    "imports": {
      "@popperjs/core": "https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/esm/popper.min.js",
      "bootstrap": "https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.esm.min.js"
    }
  }
  </script>
    <script type="module">
      import { Octokit, App } from "https://esm.sh/octokit";
      import { restEndpointMethods } from "https://esm.sh/@octokit/plugin-rest-endpoint-methods";
      import * as bootstrap from "bootstrap";
      import { MMCategories } from "./js/mmcategories.js";

      var authToken = "";
      var fileBase64 = "";

      // Info about the user:
      var username = "";
      var fullName = "";
      var email = "";
      var avatarUrl = "";

      // Valid repos of the user:
      var repos = [];
      var selectedRepo = null;
      var database = [];
      var databaseSha = "";

      // Modifying:
      var songToEdit = undefined;


      async function userLogin(){
        try {
          //loadForm();
          //return;

          // We put an overlay to prevent more user action
          $("#loadingOverlay").removeClass("d-none");

          // Get the token the user put
          authToken = $("#txtGithubAuthToken").val();
          const octokit = new Octokit({ auth: authToken });

          // Get the username of this token
          var user = await octokit.request('GET /user');
          username = user.data.login;
          fullName = user.data.name;
          email = user.data.email;
          avatarUrl = user.data.avatar_url;

          // Load the user info
          $("#niAvatar").removeClass("d-none");
          $("#imgAvatar").prop("src", avatarUrl);
          $("#niUsername").removeClass("d-none");
          $("#lbUsername").text(username);

          // Get their repos
          var allRepos = await octokit.request('GET /users/{username}/repos', {
            username: username,
          });
          
          // Check all the repos to see which one are a z64 repo
          await Promise.all(allRepos.data.map(async (repo) => {

            // If it's a fork, query the original repo
            var originalRepoOwner = repo.owner.login;
            var originalRepoAvatarUrl = avatarUrl;
            if(repo.fork){
              var originalRepo = await octokit.request('GET /repos/{owner}/{repo}', {
                owner: repo.owner.login,
                repo: repo.name
              });
              originalRepoOwner = originalRepo.data.parent.owner.login;
              originalRepoAvatarUrl = originalRepo.data.parent.owner.avatar_url;
            }

            // Try to get the z64musicpacker.properties file from the original repo
            // We don't use raw.githubusercontent.com, since it has a cache delay of 300 seconds (5 mins) that can cause issues
            var response = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
              owner: originalRepoOwner,
              repo: repo.name,
              path: "z64musicpacker.properties"

            }).catch((error) => {
              //console.log(`${repo.name} is not a z64 repo`);
            });

            // TODO: Add version, and compatible files to z64musicpacker.properties
            
            // If we find a z64musicpacker.properties file, this is a compatible repo!
            if(response !== undefined){
              // Read the file
              var properties = JSON.parse(atob(response.data.content));

              // Load the repo into our list
              repos.push({
                repoId: repo.id,
                repoName: repo.name,
                repoUrl: repo.url,
                repoDefaultBranch: repo.default_branch,
                repoIsFork: repo.fork, // <-- Make this tool also available for repo owners

                originalRepoOwner: originalRepoOwner,
                originalRepoAvatarUrl: originalRepoAvatarUrl,

                // Import Z64 music packer properties
                ...properties,
              });
            }
          }));

          // Check if we have z64 fork repos available
          if(repos.length == 0){
            toast("No Z64 repos found for this account!");
            $("#loadingOverlay").addClass("d-none");
            return;

          } else{
            // Add the repos as buttons
            repos.forEach((repo, i) => {
              $("#containerRepo").append(
                `<button type="button" class="btn btn-outline-light w-100 mb-3" id="btnSelectRepo${i}">
                  <div class="row">
                    <img class="rounded-circle ml-3 col-auto" width="45" height="45" src="${repo.originalRepoAvatarUrl}" />
                    <div class="col text-start">
                      <h5 class="mb-0">${repo.name}</h5>
                      <span class="opacity-500">${repo.description}</span>
                    </div>
                  </div>
                </button>`
              );
              $(`#btnSelectRepo${i}`).on("click", function(){
                selectRepo(repo);
              });
            });

            // Once we finish, we change form and stop the loading
            $("#loadingOverlay").addClass("d-none");
            $("#panelAuthorization").addClass("d-none");
            $("#panelRepoSelection").removeClass("d-none");
          }

          // If we catch an error, show it to the user
          // TODO: USE A MORE USER-FRIENDLY WAY TO SHOW THE ERROR
        } catch(e){
          $("#loadingOverlay").addClass("d-none");
          toast(e);
        }
      }

      async function selectRepo(repo){
        selectedRepo = repo;
        $("#loadingOverlay").removeClass("d-none");

        // Try to sync the repo and collect the database... we need it for the form
        var err = await syncRepoAndGetLatestDatabase();
        if(err != null){
          toast(err);

        } else{
          // We synced and got the db! Now we load the form
          $("#panelRepoSelection").addClass("d-none");
          $("#panelSubmissionDetails").removeClass("d-none");
        }

        $("#imgRepoAvatar").attr("src", repo.originalRepoAvatarUrl);
        $("#lbRepoName").text(repo.name);
        $("#loadingOverlay").addClass("d-none");
      }

      async function syncRepoAndGetLatestDatabase(){
        const octokit = new Octokit({ auth: authToken });
        var error = null;
        database = [];

        // First, if the current repo is a fork, we try to sync to the latest commit
        if(selectedRepo.repoIsFork){
          var syncResponse = await octokit.request('POST /repos/{owner}/{repo}/merge-upstream', {
            owner: username,
            repo: selectedRepo.repoName,
            branch: selectedRepo.repoDefaultBranch
          }).catch((err) =>{
            error = `Couldn't sync fork to the latest commit: ${err}`;
          });
          if(syncResponse === undefined) return error;
        }
        
        
        // Collect the database json file
        var dbResponse = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
          owner: username,
          repo: selectedRepo.repoName,
          path: selectedRepo.database
        }).catch((err) => {
          error = `Couldn't get database file from the repo: ${err}`;
        });
        if(dbResponse === undefined) return error;

        // Load the database
        try{
          database = JSON.parse(atob(dbResponse.data.content));
          databaseSha = dbResponse.data.sha;

        } catch(e){
          toast(`Couldn't process database file, it could be corrupted: ${e}.\n\nThe process will continue, but the database will be remade.`);
          database = [];
          databaseSha = dbResponse.data.sha;
          return;
        }

        // Now that we are loaded, fill up the required forms
        var games = new Bloodhound({
          datumTokenizer: Bloodhound.tokenizers.whitespace,
          queryTokenizer: Bloodhound.tokenizers.whitespace,
          local: [...new Set(database.map((d) => d.game))],
        });
        $("#txtGameName").typeahead({
          hint: true,
          highlight: true, /* Enable substring highlighting */
          minLength: 1, /* Specify minimum characters required for showing suggestions */
        }, {
          name: 'games',
          source: games,
        });

        // Also fill the song selector for modifying purposes
        var songs = new Bloodhound({
          datumTokenizer: Bloodhound.tokenizers.whitespace,
          queryTokenizer: Bloodhound.tokenizers.whitespace,
          local: [...new Set(database.map((d) => d.game + " | " + d.song))],
        });
        $("#txtSongSelect").typeahead({
          hint: true,
          highlight: true,
          minLength: 1,
        }, {
          name: 'songs',
          source: songs,
        });

        //toast("Database loaded!");
      }


      async function selectSongToModify(){
        // First, obtain the selected song
        var fullName = $("#txtSongSelect").val().split(" | ");
        if(fullName.length != 2){
          toast("Not a valid song selected");
          return;
        }
        songToEdit = database.find(v => v.game == fullName[0] && v.song == fullName[1]);
        if(songToEdit == undefined){
          toast("The selected song is not in the repo!");
          return;
        }

        // Now that we got our song, fill the form with it
        $("#txtGameName").val(songToEdit.game);
        $("#txtSongName").val(songToEdit.song);
        $("#txtComposers").val(toArray(songToEdit.composers).join(", "));
        $("#txtConverters").val(toArray(songToEdit.converters).join(", "));
        $("#txtPreviewLink").val(songToEdit.preview);

        // Also, make fileUpload optional, when we only want to modify metadata and not the file itself
        $("#fileUpload")[0].required = false;
        $("#mainForm").removeClass("d-none");
      }


      async function processFile(event) {
        // Read the file as a zip file
        // https://stuk.github.io/jszip/documentation/api_jszip.html
        try{
          $("#loadingOverlay").removeClass("d-none");
          var file = event.target.files[0];
          fileBase64 = (await toBase64(file)).split(",").pop();

          // Open the file as a zip
          var zip = new JSZip();
          zip.loadAsync(file).then(function(zip) {

            // If it's not a valid file, we just stop the process here
            var ootrs = file.name.endsWith(".ootrs");
            if(!ootrs && !file.name.endsWith(".mmrs")) {
              toast("Not a valid z64 file (ootrs, mmrs)");
              $("#fileUpload").val("");
              $("#pInformationFromFile").addClass("d-none");
              return;
            }
            
            var usesCustomBank = false;
            var usesCustomSamples = false;

            // Run over each file and extract data
            zip.forEach(function(path, file) {

              // Read the OOTRS-only meta file
              if(ootrs && path.endsWith(".meta")){
                file.async("text").then(function(text) {
                  var lines = text.split("\n");
                  lines.forEach((line, i) => {
                    switch(i){
                      case 0: $("#lbInternalName").text(line); break;
                      case 2: $("#lbSongType").text((line || "bgm").toLowerCase()); break; // <-- By default, songs without this line are bgm
                      case 3: $("#lbMusicGroups").text(line); break;
                    }
                  });
                });
              }

              // Read the MMRS-only categories file
              if(!ootrs && path == "categories.txt"){
                file.async("text").then(function(text) {
                  var categories = text.replace('-', ','); // <-- Normalize separator
                  $("#lbCategories").text(categories);

                  // Detect if the categories are correctly mapped
                  // TODO: THESE ARE NOT ALL THE CATEGORIES THERE ARE... ADD AN UTILITY CLASS FOR THIS STUFF
                  var catArray = categories.split(',');
                  var isFanfare = catArray.every(cat => MMCategories.isFanfare(cat));
                  var isBgm = catArray.every(cat => MMCategories.isBgm(cat));
                  console.log(catArray + ' ' + isFanfare + '  ' + isBgm);
                  if(isFanfare) $("#lbSongType").text("fanfare");
                  else if(isBgm) $("#lbSongType").text("bgm");
                  else {
                    // This song has mixed categories! We cannot accept it...
                    toast(`This file has missing or mixed bgm and fanfare categories!\nFix the categories.txt file so they ONLY has bgm or ONLY fanfare categories.`);
                    clearFileInput();

                  }
                });
              }

              // Check custom bank and samples
              if(path.endsWith(".zbank")) usesCustomBank = true;
              if(path.endsWith(".zsound")) usesCustomSamples = true;
            });

            // Load the info for both file types
            $("#lbFormat").text(ootrs ? "OOTRS" : "MMRS");
            $("#lbUsesCustomBank").text(usesCustomBank ? "Yes" : "No");
            $("#lbUsesCustomSamples").text(usesCustomSamples ? "Yes" : "No");

            // Toggle the info only for each file type
            $("#lbOOTRSOnlyInfo").toggleClass("d-none", !ootrs);
            $("#lbMMRSOnlyInfo").toggleClass("d-none", ootrs);

            // Show the information
            $("#pInformationFromFile").removeClass("d-none");

            // TODO: LOAD THE FORM IN THE CORRECT FORMAT (ootrs or mmrs)
            // If needed tho...

            $("#loadingOverlay").addClass("d-none");

            
          // File doesn't have the zip format
          }, function() {
            toast("Not a valid zip file");
            clearFileInput();
          });

        } catch(e){
          toast(`Couldn't process the file: ${e}`);
          clearFileInput();
        }
      }
      function clearFileInput(){
        fileBase64 = "";
        $("#pInformationFromFile").addClass("d-none");
        $("#fileUpload").val("");
        $("#loadingOverlay").addClass("d-none");
      }
      const toBase64 = file => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
      });


      function clearForm(){
        clearFileInput();
        $("#txtGameName").val("");
        $("#txtSongName").val("");
        $("#txtComposers").val("");
        $("#txtConverters").val("");
        $("#txtPreviewLink").val("");
        $("#txtNotes").val("");
        $("#mainForm").removeClass("was-validated");

        // Edit cleanings
        $("#txtSongSelect").val("");
        $("#fileUpload")[0].required = true;
        songToEdit = undefined;
      }
      async function submitForm(){

        // Check if the form is valid first
        var form = $("#mainForm")[0];
        var formIsValid = form.checkValidity();
        $("#mainForm").addClass("was-validated");

        // Custom validators
        $("#txtSongName, #txtGameName").trigger("input");
        
        // Perform a vanilla check and a custom validation check
        if(!formIsValid || $("#mainForm").find(".is-invalid").length > 0) return;
        

        // Open octokit and trigger the overlay
        const octokit = new Octokit({ auth: authToken });
        $("#loadingOverlay").removeClass("d-none");

        // Get the latest database
        // Is this new one required?
        var syncError = await syncRepoAndGetLatestDatabase();
        if(syncError != null){
          toast(syncError);
          $("#loadingOverlay").addClass("d-none");
          return;
        }

        // CHECK IF WE ARE IN EDIT MODE
        var editMode = songToEdit != undefined;
        var originalFilePath = songToEdit?.file;

        // Create the new entry
        // If we are editing, just grab the existing entry
        var entry = songToEdit;

        // Add an identifier if we are creating a new entry
        if(!editMode){
          entry = {};
          entry.uuid = crypto.randomUUID(); // <-- uuid v4
        }

        entry.game = $("#txtGameName").val();
        entry.song = $("#txtSongName").val();
        entry.composers = toArray($("#txtComposers").val());
        entry.converters = toArray($("#txtConverters").val());
        entry.preview = $("#txtPreviewLink").val();

        // If we have a file selected... update the path
        if(fileBase64.length > 0){
          entry.type = $("#lbSongType").val();
          entry.categories = toArray($("#lbFormat").text() == "OOTRS" ? $("#lbMusicGroups").text() : $("#lbCategories").text());
          entry.usesCustomBank = $("#lbUsesCustomBank").text() == "Yes";
          entry.usesCustomSamples = $("#lbUsesCustomSamples").text() == "Yes";

          // Generate a local path for the entry
          var extension = $("#lbFormat").text().toLowerCase();
          var fileLocalPath = entry.game + "/" + entry.song + "." + extension;
          var finalPath = selectedRepo.binaries + fileLocalPath;
          entry.file = fileLocalPath;
        }

        // Add this entry to the json file
        if(editMode){
          var entryIndex = database.findIndex(d => d.uuid == entry.uuid);
          database[entryIndex] = entry;

        } else{
          database.push(entry);
        }

        // If we have a file selected, upload it as a new commit
        if(fileBase64.length > 0){

          // If we are editing, get the file SHA we are trying to edit
          var fileSha = null;
          if(editMode){
            var originalPath = selectedRepo.binaries + originalFilePath;
            var getFileResponse = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
              owner: username,
              repo: selectedRepo.repoName,
              path: originalPath,
            }).catch((err) => {
              err = `Couldn't get original file from the repo: ${err}`;
            });
            if(getFileResponse === undefined) {
              $("#loadingOverlay").addClass("d-none");
              return;
            }
            fileSha = getFileResponse.data.sha;

            // If the filename will be different, then delete the original file for a clean replacement
            // WE HAVE TO DO THIS, since the unique names are needed to prevent duplication or overwrites
            if(originalFilePath != fileLocalPath){
              var deleteFileResponse = await octokit.request('DELETE /repos/{owner}/{repo}/contents/{path}', {
                owner: username,
                repo: selectedRepo.repoName,
                path: originalPath,
                message: `Delete file ${entry.file} for replacement`,
                sha: fileSha,
              }).catch((err) => {
                err = `Couldn't delete original file from the repo: ${err}`;
              });
              if(deleteFileResponse === undefined){
                $("#loadingOverlay").addClass("d-none");
              return;
              }
              fileSha = null; // <-- Reset the sha, since we will be creating a new file
            }
          }

          // Finally, add or update the file
          var uploadFileResult = await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
            owner: username,
            repo: selectedRepo.repoName,
            path: finalPath,
            message: `${editMode ? "Modify" : "Add new"} file ${entry.file}`,
            content: fileBase64,
            sha: fileSha,
          }).catch((err) => {
            toast(`Couldn't upload the new file (${finalPath}) to the repo: ${err}`);
          });
          if(uploadFileResult === undefined) {
            $("#loadingOverlay").addClass("d-none");
            return;
          }
        }
        

        // Update the database
        var updateDatabaseResult = await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
          owner: username,
          repo: selectedRepo.repoName,
          path: selectedRepo.database,
          message: `${editMode ? "Modify" : "Add"} entry in database for file ${entry.file}`,
          content: btoa(JSON.stringify(database, null, 2)), // <- We add spaces for readability for maintainers
          sha: databaseSha
          
        }).catch((err) => {
          toast(`Couldn't update database (${selectedRepo.database}) on the repo: ${err}`);
        });
        if(updateDatabaseResult === undefined) {
          $("#loadingOverlay").addClass("d-none");
          return;
        }


        // Do a pull request with the newly added files
        if(selectedRepo.repoIsFork){

          // We create a comment for this new entry
          var additionalNotes = $("#txtNotes").val();
          var comment = `## ${editMode ? "Modify" : "Add new"} song: ${entry.game} - ${entry.song}\n### User's notes:\n"${additionalNotes || "None"}"\n### Entry added:\n<details>\n<summary>Spoiler</summary>\n\n\`\`\`\n${JSON.stringify(entry, null, 2)}\n\`\`\`\n\n</details>`;

          // Check if a pull request is already up for this repo
          var currentPRResult = await octokit.request('GET /repos/{owner}/{repo}/pulls', {
            owner: selectedRepo.originalRepoOwner,
            repo: selectedRepo.repoName,
            state: "open",
            head: username + ":" + selectedRepo.repoDefaultBranch,

          }).catch((err) => {
            toast(`Couldn't fetch current pull requests from repository: ${err}`);
          });
          if(currentPRResult === undefined) {
            $("#loadingOverlay").addClass("d-none");
            return;
          }

          // If there is no current PR, we add a new one
          if(currentPRResult.data.length == 0){
            var pullRequestResult = await octokit.request('POST /repos/{owner}/{repo}/pulls', {
              owner: selectedRepo.originalRepoOwner,
              repo: selectedRepo.repoName,
              title: `${editMode ? "Modify" : "Add new"} song: ${entry.game} - ${entry.song}`,
              body: comment,
              head: username + ":" + selectedRepo.repoDefaultBranch, // <-- We only do to the main branch... I could implement it for selected branches tho
              base: selectedRepo.repoDefaultBranch,

            }).catch((err) => {
              toast(`Couldn't create a pull request: ${err}`);
            });
            if(pullRequestResult === undefined) {
              $("#loadingOverlay").addClass("d-none");
              return;
            }

          // If there IS an already opened PR, just add a comment to go in par with the just recently made commit
          } else{
            var prNumber = currentPRResult.data[0].number;
            var commentResult = await octokit.request('POST /repos/{owner}/{repo}/issues/{issue_number}/comments', {
              owner: selectedRepo.originalRepoOwner,
              repo: selectedRepo.repoName,
              issue_number: prNumber,
              body: comment,

            }).catch((err) => {
              toast(`Couldn't comment on the already created pull request: ${err}`);
            });
            if(commentResult === undefined) {
              $("#loadingOverlay").addClass("d-none");
              return;
            };
          }
        }
        
        toast("Process completed!");
        clearForm();
        await syncRepoAndGetLatestDatabase();
        $("#loadingOverlay").addClass("d-none");
      }


      // Utils
      // TODO: CHANGE STYLE FOR ERROR TOASTS
      function toast(message){
        var t = bootstrap.Toast.getOrCreateInstance($("#toast")[0]);
        $("#toastBody").text(message);
        t.show();
      }
      function toArray(v){
        if(Array.isArray(v)) return v;
        else if(typeof v === 'string') return v.split(',').map(x => x.trim()).filter(x => x);
        else return [];
      }

      // Document ready
      $(function(){
        // Submit mappings
        $("#btnLogin").on("click", userLogin);
        $("#btnSongSelect").on("click", selectSongToModify);
        $("#btnSubmit").on("click", submitForm);

        // We don't want to trigger an actual submit, since we don't have any backend
        $("#mainForm").on("submit", function(e){
          e.preventDefault();
          e.stopPropagation();
        });
        
        // Form events
        $("#fileUpload").on("change", processFile);
        $("#txtGameName, #txtSongName").alphanum({
          allow: "!@#$%^&()+=[]\';,{}~`.- _", // We allow all character accepted as filenames
          //disallow: '\\/:*?"<>|',
        });
        
        $("input[name='rbSubmissionType']").on("change", function(){
          clearForm();
          $("#mainForm").toggleClass("d-none", this.value != "new");
          $("#panelSongSelect").toggleClass("d-none", this.value != "edit");
        });

        $("#txtSongName, #txtGameName").on("input", function(){
          var game = $("#txtGameName").val();
          var song = $("#txtSongName").val();
          if(!game || !song){
            $("#txtSongName, #txtGameName").each(function(){ this.setCustomValidity("invalid"); });
            $("#txtSongName").siblings(".invalid-feedback").html(`Please insert a game and name for the song.`);
            return;
          }

          // Check if is duplicated
          // Ignore this requirement if we are editing an already existing song
          var isInDB = database.some(s => s.game == game && s.song == song);
          var isDuplicate = isInDB && (songToEdit != undefined ? !(songToEdit.game == game && songToEdit.song == song) : true)

          $("#txtSongName, #txtGameName").each(function(){ this.setCustomValidity(isDuplicate ? "invalid" : ""); });
          $("#txtSongName").siblings(".invalid-feedback").html(`<b>This song is already in this repo!</b><br>
                If this is another version of the song, add something to differentiate it, like "Rosalina's Observatory (Tolin version)".<br>
                If you are trying to modify an existing song, use the "Modify/update an existing song" button above.`);
        });
      });
    </script>


    <div id="loadingOverlay" class="loading-overlay d-none">
      <i class="fa-solid fa-spinner fa-spin-pulse fa-3x"></i>
    </div>

    <nav class="navbar navbar-expand-lg bg-body-tertiary" style="padding-left: 8px; height: 46.5px;">
      <a class="navbar-brand text-secondary" style="width: 242px" href="#">
        Z64 Submission Form
      </a>
      
      <div class="col"></div>

      <div class="col-auto ml-auto d-none" id="niUsername">
        Logged as <b id="lbUsername">...</b>
      </div>

      <div class="col-auto px-2 d-none" id="niAvatar">
        <img id="imgAvatar" class="rounded-circle bg-white" width="30" height="30" src="" />
      </div>
    </nav>

    <div class="container">
      <div class="row justify-content-md-center pt-3 pb-5">

        <!-- AUTHORIZATION -->
        <div class="card bg-body-tertiary col p-3" style="max-width: 500px;" id="panelAuthorization">
          <h5>Authorization</h5>
          <p>This tools works by using the GitHub API to create commits and pull requests for you.</p>

          <div class="form-group mb-3">
            <label>GitHub authorization token:</label>
            <p class="hint">The token with access to the fork of the repository you are trying to send this file.</p>
            <input type="text" id="txtGithubAuthToken" class="form-control" placeholder="github_pat_xxxxx... or ghp_xxxxx..." />
          </div>

          <button type="button" class="btn btn-primary" id="btnLogin">Login</button>
        </div>


        <!-- SELECT A REPO -->
        <div class="card bg-body-tertiary col p-3 d-none" style="max-width: 500px;" id="panelRepoSelection">
          <h5>Select a repository</h5>
          <p>Select the repository you will be submitting a new music track.</p>
          <div class="container" id="containerRepo">
          </div>
        </div>


        <!-- SUBMISSION DETAILS -->
        <div class="card bg-body-tertiary col p-0 g-3 d-none" style="max-width: 500px;" id="panelSubmissionDetails">
          
          <div class="row g-0 py-2 align-items-center border-bottom bg-primary-subtle rounded-top">
            <i class="col-auto fa-solid fa-lg fa-arrow-left me-auto ms-3"></i>
            <img class="col-auto rounded-circle bg-white" id="imgRepoAvatar" width="30" height="30" src="" />
            <h5 class="col-auto ps-2 pe-3 mb-0 me-auto" id="lbRepoName"></h5>
          </div>

          <div id="preMainForm" class="p-3">
            <h5>Submission details</h5>
            <p>Select what type of submission you want to do:</p>
  
            <div class="row g-0">
              <div class="p-3 col me-2 border rounded">
                <div class="row g-0">
                  <input class="form-check-input col-auto" type="radio" name="rbSubmissionType" id="rbSubmissionTypeNew" value="new">
                  <label class="form-check-label col ps-3" for="rbSubmissionTypeNew">
                    <b>Upload</b> a new song not in the repo
                  </label>
                </div>
              </div>
              <div class="p-3 col ms-2 border rounded">
                <div class="row g-0">
                  <input class="form-check-input col-auto" type="radio" name="rbSubmissionType" id="rbSubmissionTypeEdit" value="edit">
                  <label class="form-check-label col ps-3" for="rbSubmissionTypeEdit">
                    <b>Modify/update</b> an existing song
                  </label>
                </div>
              </div>
            </div>
          </div>

          <div id="panelSongSelect" class="d-none p-3">
            <div class="form-group mb-3">
              <label>Song to modify:</label>
              <p class="hint">The name of the song you're trying to modify.</p>
              <input id="txtSongSelect" type="text" class="form-control" placeholder="Write here the name of the song..." />
            </div>

            <button id="btnSongSelect" type="button" class="btn btn-primary w-100">
              <i class="fa-solid fa-edit me-2"></i>Select this song
            </button>
          </div>

          <!--TODO: Add typeahead for choosing the existing track on edit mode-->

          <form id="mainForm" class="d-none needs-validation p-3 pt-0">
            
            <div class="form-group mb-3">
              <label>File:</label>
              <p class="hint">The z64 song file you are uploading (ootrs, mmrs). If you are only editing the metadata of an existing track, you can leave this input empty to not make any changes to the already uploaded file.</p>
              <input id="fileUpload" type="file" class="form-control" accept=".ootrs,.mmrs" required/>
              <p class="opacity-600 mb-0 d-none" id="pInformationFromFile">
                Information extracted from the file:<br>
                <b>• Format:</b> <span id="lbFormat">...</span><br>
                <b>• Type:</b> <span id="lbSongType">...</span><br><!--bgm or fanfare-->
                <span id="lbOOTRSOnlyInfo">
                  <b>• Internal name:</b> <span id="lbInternalName">...</span><br>
                  <b>• Music groups:</b> <span id="lbMusicGroups">...</span><br>
                </span>
                <span id="lbMMRSOnlyInfo">
                  <b>• Categories:</b> <span id="lbCategories">...</span><br>
                </span>
                <b>• Uses custom bank:</b> <span id="lbUsesCustomBank">...</span><br>
                <b>• Uses custom samples:</b> <span id="lbUsesCustomSamples">...</span>
              </p>
              <div class="invalid-feedback">
                A valid file is needed for upload.
              </div>
            </div>
  
            <hr>
  
            <div class="form-group mb-3">
              <label>Game name:</label>
              <p class="hint">The name of the game your song comes from.</p>
              <input id="txtGameName" type="text" class="form-control" placeholder="E.g.: Super Mario Galaxy" />
            </div>
  
            <!--TODO: Make sure in new mode, we are not using an existing track's name-->
            <div class="form-group mb-3">
              <label>Song name:</label>
              <p class="hint">The actual name of the song.</p>
              <input id="txtSongName" type="text" class="form-control" placeholder="E.g.: Rosalina's Observatory" />
              <div class="invalid-feedback">
                Please insert a game and name for the song.
              </div>
            </div>

            <!-- TODO: Implement this on future... Right now it may be difficult to do, because we have to prevent name duplication. -->
            <!-- Maybe we could do an abreviated GAME name, and let the name of the song be. Eg. Super Mario Galaxy to SMG, etc... -->
            <!--<div class="form-group mb-3">
              <label>Short display name:</label>
              <p class="hint">
                An alternative very short name for the song, only 28 characters long.<br>
                This name could be used for 
              </p>
              <input id="txtDisplayName" type="text" class="form-control" placeholder="E.g.: SMG-RosalinaObservatory" maxlength="28" />
            </div>-->
  
            <hr>
  
            <div class="form-group mb-3">
              <label>Composer(s):</label>
              <p class="hint">A list of the names of the original composers of this song.<br>
              List multiple composer separated by comma.</p>
              <input id="txtComposers" type="text" class="form-control" placeholder="E.g.: Koji Kondo, Kazumi Totaka" required />
              <div class="invalid-feedback">
                Please insert at least one composer. Google is your best friend here. If you can't seem to find one, use "Unknown".
              </div>
            </div>
  
            <div class="form-group mb-3">
              <label>Converter(s):</label>
              <p class="hint">A list of the names of ones who converted this song to the Zelda 64 format.<br>
              List multiple converters separated by comma.</p>
              <input id="txtConverters" type="text" class="form-control" placeholder="E.g.: Tolin, Owl is not a Cat" required />
              <div class="invalid-feedback">
                Please insert at least one converter. Your name should be here.
              </div>
            </div>
  
            <hr>
  
            <div class="form-group mb-3">
              <label>Preview link:</label>
              <p class="hint">
                Link to a preview of this song. Can it be on two formats:<br>
                <b>• YouTube link:</b> link to a video uploaded to YouTube of your version of the song.<br>
                <b>• Direct sound file link:</b> direct link to a sound file (.mp3, .wav, etc) uploaded on a public site (Internet Archive, Discord, GitHub, etc).
              </p>
              <input id="txtPreviewLink" type="text" class="form-control" pattern="https?://.+" required />
              <div class="invalid-feedback">
                A valid preview link is required. Must be <b>https://</b>
              </div>
            </div>
  
            <div class="form-group mb-3">
              <label>Notes:</label>
              <p class="hint">
                Additional notes for the people handling your submission.
              </p>
              <input id="txtNotes" type="text" class="form-control" />
            </div>
  
            <button id="btnSubmit" type="submit" class="btn btn-primary w-100">
              <i class="fa-solid fa-paper-plane me-2"></i>Submit
            </button>
          </form>

          
        </div>
      </div>
    </div>

    <div class="toast-container position-fixed bottom-0 end-0 p-3">
      <div id="toast" class="toast align-items-center bg-primary-subtle text-primary-emphasis" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="d-flex">
          <div class="toast-body" id="toastBody">
            Hello, world! This is a toast message.
          </div>
          <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
      </div>
    </div>
    
  </body>
</html>