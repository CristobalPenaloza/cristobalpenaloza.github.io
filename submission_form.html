<!DOCTYPE html>
<html data-theme='dark'>
  <head>
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="css/themes.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap-themed.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />

    <!-- JQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/themes/smoothness/jquery-ui.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js"></script>

    <!-- Other stuff -->
    <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
  </head>
  <body>
    <style>
      .loading-overlay {
        position: fixed;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        color: var(--primary-normal);
        background-color: var(--loading-overlay-backdrop-color);
        z-index: 5600;
      }
      .loading-overlay i{
          position: absolute;
          top: 47%;
          left: 47%;
      }

      label{
        margin-bottom: .1rem;
      }
      .hint{
        padding: 0;
        margin: 0;
        margin-bottom: .25rem;
        font-size: 80%;
        opacity: .5;
      }
    </style>

    <script type="module">
      import { Octokit, App } from "https://esm.sh/octokit";
      import { restEndpointMethods } from "https://esm.sh/@octokit/plugin-rest-endpoint-methods";

      var authToken = "";
      var fileBase64 = "";

      // Info about the user:
      var username = "";
      var fullName = "";
      var email = "";
      var avatarUrl = "";

      // Valid repos of the user:
      var repos = [];
      var selectedRepo = null;
      var database = [];
      var databaseSha = "";

      async function userLogin(){
        try {
          //loadForm();
          //return;

          // We put an overlay to prevent more user action
          $("#loadingOverlay").removeClass("d-none");

          // Get the token the user put
          authToken = $("#txtGithubAuthToken").val();
          const octokit = new Octokit({ auth: authToken });

          // Get the username of this token
          var user = await octokit.request('GET /user');
          username = user.data.login;
          fullName = user.data.name;
          email = user.data.email;
          avatarUrl = user.data.avatar_url;

          // Load the user info
          $("#niAvatar").removeClass("d-none");
          $("#imgAvatar").prop("src", avatarUrl);
          $("#niUsername").removeClass("d-none");
          $("#lbUsername").text(username);

          // Get their repos
          var allRepos = await octokit.request('GET /users/{username}/repos', {
            username: username,
          });
          
          // Check all the repos to see which one are a z64 repo
          await Promise.all(allRepos.data.map(async (repo) => {

            // If it's a fork, query the original repo
            var originalRepoOwner = repo.owner.login;
            var originalRepoAvatarUrl = avatarUrl;
            if(repo.fork){
              var originalRepo = await octokit.request('GET /repos/{owner}/{repo}', {
                owner: repo.owner.login,
                repo: repo.name
              });
              originalRepoOwner = originalRepo.data.parent.owner.login;
              originalRepoAvatarUrl = originalRepo.data.parent.owner.avatar_url;
            }

            // Try to get the z64musicpacker.properties file from the original repo
            // We don't use raw.githubusercontent.com, since it has a cache delay of 300 seconds (5 mins) that can cause issues
            var response = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
              owner: originalRepoOwner,
              repo: repo.name,
              path: "z64musicpacker.properties"

            }).catch((error) => {
              //console.log(`${repo.name} is not a z64 repo`);
            });

            // TODO: Add version, and compatible files to z64musicpacker.properties
            
            // If we find a z64musicpacker.properties file, this is a compatible repo!
            if(response !== undefined){
              // Read the file
              var properties = JSON.parse(atob(response.data.content));
              console.log(properties);

              // Load the repo into our list
              repos.push({
                repoId: repo.id,
                repoName: repo.name,
                repoUrl: repo.url,
                repoDefaultBranch: repo.default_branch,
                repoIsFork: repo.fork, // <-- Make this tool also available for repo owners

                originalRepoOwner: originalRepoOwner,
                originalRepoAvatarUrl: originalRepoAvatarUrl,

                // Import Z64 music packer properties
                ...properties,
              });
            }
          }));

          // Check if we have z64 fork repos available
          if(repos.length == 0){
            alert("No Z64 repos found for this account!");
            $("#loadingOverlay").addClass("d-none");
            return;

          } else{
            // Add the repos as buttons
            repos.forEach((repo, i) => {
              $("#containerRepo").append(
                `<button type="button" class="btn btn-outline-dark w-100 mb-3" id="btnSelectRepo${i}">
                  <div class="row">
                    <img class="rounded-circle ml-3" width="45" height="45" src="${repo.originalRepoAvatarUrl}" />
                    <div class="col text-left">
                      <h5 class="mb-0">${repo.name}</h5>
                      <span class="opacity-500">${repo.description}</span>
                    </div>
                  </div>
                </button>`
              );
              $(`#btnSelectRepo${i}`).on("click", function(){
                selectRepo(repo);
              });
            });

            // Once we finish, we change form and stop the loading
            $("#loadingOverlay").addClass("d-none");
            $("#panelAuthorization").addClass("d-none");
            $("#panelRepoSelection").removeClass("d-none");
          }

          // If we catch an error, show it to the user
          // TODO: USE A MORE USER-FRIENDLY WAY TO SHOW THE ERROR
        } catch(e){
          $("#loadingOverlay").addClass("d-none");
          alert(e);
        }
      }

      async function selectRepo(repo){
        selectedRepo = repo;
        console.log(selectedRepo);
        $("#loadingOverlay").removeClass("d-none");
        
        // Try to sync the repo and collect the database... we need it for the form
        var err = await syncRepoAndGetLatestDatabase();
        if(err != null){
          alert(err);

        } else{
          // We synced and got the db! Now we load the form
          $("#panelRepoSelection").addClass("d-none");
          $("#panelSubmissionDetails").removeClass("d-none");
        }

        $("#loadingOverlay").addClass("d-none");
      }



      async function syncRepoAndGetLatestDatabase(){
        const octokit = new Octokit({ auth: authToken });
        var error = null;
        database = [];
        

        // First, if the current repo is a fork, we try to sync to the latest commit
        if(selectedRepo.repoIsFork){
          var syncResponse = await octokit.request('POST /repos/{owner}/{repo}/merge-upstream', {
            owner: username,
            repo: selectedRepo.repoName,
            branch: selectedRepo.repoDefaultBranch
          }).catch((err) =>{
            error = `Couldn't sync fork to the latest commit: ${err}`;
          });
          console.log(syncResponse);
          if(syncResponse === undefined) return error;
        }
        
        
        // Collect the database json file
        var dbResponse = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
          owner: username,
          repo: selectedRepo.repoName,
          path: selectedRepo.database
        }).catch((err) => {
          error = `Couldn't get database file from the repo: ${err}`;
        });
        if(dbResponse === undefined) return error;
        console.log(dbResponse);

        // Load the database
        database = JSON.parse(atob(dbResponse.data.content));
        databaseSha = dbResponse.data.sha;
        console.log("Database loaded!");
        console.log(database);
      }



      async function processFile(event) {
        // Read the file as a zip file
        // https://stuk.github.io/jszip/documentation/api_jszip.html
        try{
          $("#loadingOverlay").removeClass("d-none");
          var file = event.target.files[0];
          fileBase64 = (await toBase64(file)).split(",").pop();
          //console.log("File processed: " + fileBase64);

          // Open the file as a zip
          var zip = new JSZip();
          zip.loadAsync(file).then(function(zip) {

            // If it's not a valid file, we just stop the process here
            var ootrs = file.name.endsWith(".ootrs");
            if(!ootrs && !file.name.endsWith(".mmrs")) {
              alert("Not a valid z64 file (ootrs, mmrs)");
              $("#fileUpload").val("");
              $("#pInformationFromFile").addClass("d-none");
              return;
            }
            
            var usesCustomBank = false;
            var usesCustomSamples = false;

            // Run over each file and extract data
            zip.forEach(function(path, file) {

              // Read the OOTRS-only meta file
              if(ootrs && path.endsWith(".meta")){
                file.async("text").then(function(text) {
                  var lines = text.split("\n");
                  lines.forEach((line, i) => {
                    switch(i){
                      case 0: $("#lbInternalName").text(line); break;
                      case 2: $("#lbSequenceType").text(line); break;
                      case 3: $("#lbMusicGroups").text(line); break;
                    }
                  });
                });
              }

              // Read the MMRS-only categories file
              if(!ootrs && path == "categories.txt"){
                file.async("text").then(function(text) {
                  $("#lbCategories").text(text);
                });
              }

              // Check custom bank and samples
              if(path.endsWith(".zbank")) usesCustomBank = true;
              if(path.endsWith(".zsound")) usesCustomSamples = true;
            });

            // Load the info for both file types
            $("#lbFormat").text(ootrs ? "OOTRS" : "MMRS");
            $("#lbUsesCustomBank").text(usesCustomBank ? "Yes" : "No");
            $("#lbUsesCustomSamples").text(usesCustomSamples ? "Yes" : "No");

            // Toggle the info only for each file type
            $("#lbOOTRSOnlyInfo").toggleClass("d-none", !ootrs);
            $("#lbMMRSOnlyInfo").toggleClass("d-none", ootrs);

            // Show the information
            $("#pInformationFromFile").removeClass("d-none");

            // TODO: LOAD THE FORM IN THE CORRECT FORMAT (ootrs or mmrs)
            // If needed tho...

            $("#loadingOverlay").addClass("d-none");

            
          // File doesn't have the zip format
          }, function() {
            alert("Not a valid zip file");
            clearFileInput();
          });

        } catch(e){
          alert(`Couldn't process the file: ${e}`);
          clearFileInput();
        }
      }
      function clearFileInput(){
        fileBase64 = "";
        $("#pInformationFromFile").addClass("d-none");
        $("#fileUpload").val("");
        $("#loadingOverlay").addClass("d-none");
      }
      const toBase64 = file => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
      });


    
      // TODO: MANAGE EDITS OF FILES
      async function submitForm(){
        const octokit = new Octokit({ auth: authToken });
        $("#loadingOverlay").removeClass("d-none");

        // Get the latest database
        var syncError = await syncRepoAndGetLatestDatabase();
        if(syncError != null){
          alert(syncError);
          $("#loadingOverlay").addClass("d-none");
          return;
        }
        

        // Create the new entry
        var entry = {
          game: $("#txtGameName").val(),
          song: $("#txtSongName").val(),
          type: $("#ddlSongType").val(),
          composers: $("#txtComposers").val(),
          converters: $("#txtConverters").val(),
          preview: $("#txtPreviewLink").val(),

          categories: $("#lbFormat").text() == "OOTRS" ? $("#lbMusicGroups").text() : $("#lbCategories").text(),
          usesCustomBank: $("lbUsesCustomBank").text() == "Yes",
          usesCustomSamples: $("lbUsesCustomSamples").text() == "Yes",
          
          uuid: crypto.randomUUID(),
        };


        // Generate a local path for the entry
        var extension = $("#lbFormat").text().toLowerCase();
        var fileLocalPath = entry.game + "/" + entry.song + "." + extension;
        var finalPath = selectedRepo.binaries + fileLocalPath;
        entry.file = fileLocalPath;
        console.log(entry);


        // Add this entry to the json file
        database.push(entry);


        // Upload the file
        // Again, this doesn't work with the octokit, so we using normal fetch again
        /*var uploadFileResult = await fetch(`https://api.github.com/repos/${username}/${selectedRepo.repoName}/contents/${finalPath}`, {
          method: "PUT",
          body: JSON.stringify({
            message: `Add new file ${fileLocalPath}`,
            content: fileBase64
          }),
          headers: {
            "Accept": "application/vnd.github+json",
            "Authorization": `Bearer ${authToken}`,
            "X-GitHub-Api-Version": "2022-11-28"
          }
        });
        if(uploadFileResult.ok != true){
          alert(`Couldn't upload the new file (${finalPath}) to the repo: ${(await uploadFileResult.json()).message}`);
          $("#loadingOverlay").addClass("d-none");
          return;
        }
        console.log(uploadFileResult);*/

        var uploadFileResult = await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
          owner: username,
          repo: selectedRepo.repoName,
          path: finalPath,
          message: `Add new file ${fileLocalPath}`,
          content: fileBase64,
          
        }).catch((err) => {
          alert(`Couldn't upload the new file (${finalPath}) to the repo: ${err}`);
        });
        if(uploadFileResult === undefined) {
          $("#loadingOverlay").addClass("d-none");
          return;
        }
        console.log(uploadFileResult);


        // Update the database
        var updateDatabaseResult = await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
          owner: username,
          repo: selectedRepo.repoName,
          path: selectedRepo.database,
          message: `Add entry in database for file ${fileLocalPath}`,
          content: btoa(database), // <-- TODO: THIS RETURNS [object Object]
          sha: databaseSha
          
        }).catch((err) => {
          alert(`Couldn't update database (${selectedRepo.database}) on the repo: ${err}`);
        });
        if(updateDatabaseResult === undefined) {
          $("#loadingOverlay").addClass("d-none");
          return;
        }
        console.log(updateDatabaseResult);


        // Do a pull request with the newly added files
        // ERROR HERE: NO COMMITS BETWEEN MAIN AND MAIN
        if(selectedRepo.repoIsFork){
          var additionalNotes = $("#txtNotes").val();
          await octokit.request('POST /repos/{owner}/{repo}/pulls', {
            owner: username,
            repo: selectedRepo.repoName,
            title: `Add new song: ${entry.game} - ${entry.song}`,
            body: `Automatic PR created with Z64 Submission Form\n\nAdditional notes: ${additionalNotes}`,
            head: selectedRepo.repoDefaultBranch, // <-- We only do to the main branch... I could implement it for selected branches tho
            base: selectedRepo.repoDefaultBranch,

          }).catch((err) => {
            alert(`Couldn't create a pull request: ${err}`);
          });
        }
        

        console.log('Process finished');
        $("#loadingOverlay").addClass("d-none");
      }



      $(function(){
        $("#btnLogin").on("click", userLogin);
        $("#btnSubmit").on("click", submitForm);
        $("#fileUpload").on("change", processFile);

        $("#ddlSubmissionType").on("change", function(){
          $("#mainForm").toggleClass("d-none", this.value != "new")
          // TODO: ADD SELECT FOR CHOOSING THE SONG TO EDIT | this.value == "edit"
        });
      });
    </script>

    <div id="loadingOverlay" class="loading-overlay d-none">
      <i class="fa-solid fa-spinner fa-spin-pulse fa-3x"></i>
    </div>

    <nav class="nav-shadow navbar fixed-top" style="padding-left: 8px; height: 46.5px;">
      <a class="navbar-brand text-secondary" style="width: 242px" href="#">
        Z64 Submission Form
      </a>
      
      <div class="col-auto ml-auto d-none" id="niUsername">
        Logged as <b id="lbUsername">...</b>
      </div>

      <div class="col-auto px-0 d-none" id="niAvatar">
        <img id="imgAvatar" class="rounded-circle" width="30" height="30" src="" />
      </div>
    </nav>

    <div class="container" style="padding-top: 46.5px;">
      <div class="row justify-content-md-center pt-5 pb-5">

        <!-- AUTHORIZATION -->
        <div class="card rounded col p-3" style="max-width: 500px;" id="panelAuthorization">
          <h5>Authorization</h5>
          <p>This tools works by using the GitHub API to create commits and pull requests for you.</p>

          <div class="form-group">
            <label>GitHub authorization token:</label>
            <p class="hint">The token with access to the fork of the repository you are trying to send this file.</p>
            <input type="text" id="txtGithubAuthToken" class="form-control" placeholder="github_pat_xxxxx... or ghp_xxxxx..." />
          </div>

          <button type="button" class="btn btn-success" id="btnLogin">Login</button>
        </div>


        <!-- SELECT A REPO -->
        <div class="card rounded col p-3 d-none" style="max-width: 500px;" id="panelRepoSelection">
          <h5>Select a repository</h5>
          <p>Select the repository you will be submitting a new music track.</p>
          <div class="container" id="containerRepo">
            <!--<button type="button" class="btn btn-outline-dark w-100 mb-3">
              <div class="row">
                <img id="imgAvatar" class="rounded-circle ml-3" width="45" height="45" src="" />
                <div class="col text-left">
                  <h5>Repo Name</h5>
                  <span class="opacity-500">Description! Description!</span>
                </div>
              </div>
            </button>-->
          </div>
        </div>


        <!-- SUBMISSION DETAILS -->
        <div class="card rounded col p-3 d-none" style="max-width: 500px;" id="panelSubmissionDetails">
          <h5>Submission details</h5>

          <div class="form-group">
            <label>Submission type:</label>
            <select id="ddlSubmissionType" class="form-control">
              <option value="">Select an option...</option>
              <option value="new">Upload a new song</option>
              <option value="edit">Modify/update existing song</option>
            </select>
          </div>

          <!--TODO: Add typeahead for choosing the existing track on edit mode-->

          <div id="mainForm" class="d-none">
            <div class="form-group">
              <label>File:</label>
              <p class="hint">The z64 song file you are uploading (ootrs, mmrs). If you are only editing the metadata of an existing track, you can leave this input empty to not make any changes to the already uploaded file.</p>
              <input id="fileUpload" type="file" class="form-control" accept=".ootrs,.mmrs" />
              <p class="opacity-600 mb-0 d-none" id="pInformationFromFile">
                Information extracted from the file:<br>
                <b>• Format:</b> <span id="lbFormat">...</span><br>
                <span id="lbOOTRSOnlyInfo">
                  <b>• Internal name:</b> <span id="lbInternalName">...</span><br>
                  <b>• Sequence type:</b> <span id="lbSequenceType">...</span><br>
                  <b>• Music groups:</b> <span id="lbMusicGroups">...</span><br>
                </span>
                <span id="lbMMRSOnlyInfo">
                  <b>• Categories:</b> <span id="lbCategories">...</span><br>
                </span>
                <b>• Uses custom bank:</b> <span id="lbUsesCustomBank">...</span><br>
                <b>• Uses custom samples:</b> <span id="lbUsesCustomSamples">...</span>
              </p>
            </div>
  
            <hr>
  
            <div class="form-group">
              <label>Game name:</label>
              <p class="hint">The name of the game your song comes from.</p>
              <input id="txtGameName" type="text" class="form-control" placeholder="E.g.: Super Mario Galaxy" />
            </div>
  
            <!--TODO: Make sure in new mode, we are not using an existing track's name-->
            <div class="form-group">
              <label>Song name:</label>
              <p class="hint">The actual name of the song.</p>
              <input id="txtSongName" type="text" class="form-control" placeholder="E.g.: Rosalina's Observatory" />
            </div>
  
            <div class="form-group">
              <label>Song type:</label>
              <p class="hint">
                <b>• Background Music (BGM):</b> looping track, used as background music.<br>
                <b>• Fanfare:</b> non looping track, used for events (e.g. when you find items).
              </p>
              <select id="ddlSongType" class="form-control">
                <option value="bgm">Background Music (BGM)</option>
                <option value="fanfare">Fanfare</option>
              </select>
            </div>
  
            <hr>
  
            <div class="form-group">
              <label>Composer(s):</label>
              <p class="hint">A list of the names of the original composers of this song.</p>
              <input id="txtComposers" type="text" class="form-control" placeholder="E.g.: Koji Kondo" />
            </div>
  
            <div class="form-group">
              <label>Converter(s):</label>
              <p class="hint">A list of the names of ones who converted this song to the Zelda 64 format.</p>
              <input id="txtConverters" type="text" class="form-control" placeholder="E.g.: Tolin" />
            </div>
  
            <hr>
  
            <div class="form-group">
              <label>Preview link:</label>
              <p class="hint">
                Link to a preview of this song. Can it be on two formats:<br>
                <b>• YouTube link:</b> link to a video uploaded to YouTube of your version of the song.<br>
                <b>• Direct sound file link:</b> direct link to a sound file (.mp3, .wav, etc) uploaded on a public site (Mega, Discord, GitHub, etc).
              </p>
              <input id="txtPreviewLink" type="text" class="form-control" />
            </div>
  
            <div class="form-group">
              <label>Notes:</label>
              <p class="hint">
                Additional notes for the people handling your submission.
              </p>
              <input id="txtNotes" type="text" class="form-control" />
            </div>
  
            <button id="btnSubmit" type="button" class="btn btn-success">Submit</button>
          </div>
          
        </div>
      </div>
    </div>
  </body>
</html>