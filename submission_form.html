<!DOCTYPE html>
<html data-bs-theme="dark">
  <head>
    <!-- CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />

    <!-- JQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/themes/smoothness/jquery-ui.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js"></script>

    <!-- Other stuff -->
    <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.alphanum/1.0.24/jquery.alphanum.min.js"></script>
    <script src="js/typeahead.bundle.js"></script>
  </head>
  <body>
    <style>
      .loading-overlay {
        position: fixed;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        color: var(--bs-primary-text-emphasis);
        background-color: rgba(24, 24, 24, .6);
        z-index: 5600;
      }
      .loading-overlay i{
        position: absolute;
        top: 47%;
        left: 47%;
      }
      label{
        margin-bottom: .1rem;
      }
      .hint{
        padding: 0;
        margin: 0;
        margin-bottom: .25rem;
        font-size: 80%;
        opacity: .5;
      }


      .tt-hint{
        opacity: .4 !important;
      }
      .tt-menu{
        width: 100%;
        background-color: var(--bs-body-bg);
        border: var(--bs-card-border-width) solid var(--bs-primary-text-emphasis);
        padding: .5rem;
        border-radius: var(--bs-border-radius);
        margin-top: .25rem;
      }
      .tt-suggestion{
        padding: .25rem;
      }
      .tt-suggestion.tt-cursor, .tt-suggestion:hover{
        background-color: var(--bs-primary);
        color: white;
        cursor: pointer;
      }
      .twitter-typeahead {
        width: 100%;
      }
    </style>

    <script type="module">
      import { Octokit, App } from "https://esm.sh/octokit";
      import { restEndpointMethods } from "https://esm.sh/@octokit/plugin-rest-endpoint-methods";

      var authToken = "";
      var fileBase64 = "";

      // Info about the user:
      var username = "";
      var fullName = "";
      var email = "";
      var avatarUrl = "";

      // Valid repos of the user:
      var repos = [];
      var selectedRepo = null;
      var database = [];
      var databaseSha = "";

      async function userLogin(){
        try {
          //loadForm();
          //return;

          // We put an overlay to prevent more user action
          $("#loadingOverlay").removeClass("d-none");

          // Get the token the user put
          authToken = $("#txtGithubAuthToken").val();
          const octokit = new Octokit({ auth: authToken });

          // Get the username of this token
          var user = await octokit.request('GET /user');
          username = user.data.login;
          fullName = user.data.name;
          email = user.data.email;
          avatarUrl = user.data.avatar_url;

          // Load the user info
          $("#niAvatar").removeClass("d-none");
          $("#imgAvatar").prop("src", avatarUrl);
          $("#niUsername").removeClass("d-none");
          $("#lbUsername").text(username);

          // Get their repos
          var allRepos = await octokit.request('GET /users/{username}/repos', {
            username: username,
          });
          
          // Check all the repos to see which one are a z64 repo
          await Promise.all(allRepos.data.map(async (repo) => {

            // If it's a fork, query the original repo
            var originalRepoOwner = repo.owner.login;
            var originalRepoAvatarUrl = avatarUrl;
            if(repo.fork){
              var originalRepo = await octokit.request('GET /repos/{owner}/{repo}', {
                owner: repo.owner.login,
                repo: repo.name
              });
              originalRepoOwner = originalRepo.data.parent.owner.login;
              originalRepoAvatarUrl = originalRepo.data.parent.owner.avatar_url;
            }

            // Try to get the z64musicpacker.properties file from the original repo
            // We don't use raw.githubusercontent.com, since it has a cache delay of 300 seconds (5 mins) that can cause issues
            var response = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
              owner: originalRepoOwner,
              repo: repo.name,
              path: "z64musicpacker.properties"

            }).catch((error) => {
              //console.log(`${repo.name} is not a z64 repo`);
            });

            // TODO: Add version, and compatible files to z64musicpacker.properties
            
            // If we find a z64musicpacker.properties file, this is a compatible repo!
            if(response !== undefined){
              // Read the file
              var properties = JSON.parse(atob(response.data.content));
              console.log(properties);

              // Load the repo into our list
              repos.push({
                repoId: repo.id,
                repoName: repo.name,
                repoUrl: repo.url,
                repoDefaultBranch: repo.default_branch,
                repoIsFork: repo.fork, // <-- Make this tool also available for repo owners

                originalRepoOwner: originalRepoOwner,
                originalRepoAvatarUrl: originalRepoAvatarUrl,

                // Import Z64 music packer properties
                ...properties,
              });
            }
          }));

          // Check if we have z64 fork repos available
          if(repos.length == 0){
            alert("No Z64 repos found for this account!");
            $("#loadingOverlay").addClass("d-none");
            return;

          } else{
            // Add the repos as buttons
            repos.forEach((repo, i) => {
              $("#containerRepo").append(
                `<button type="button" class="btn btn-outline-light w-100 mb-3" id="btnSelectRepo${i}">
                  <div class="row">
                    <img class="rounded-circle ml-3 col-auto" width="45" height="45" src="${repo.originalRepoAvatarUrl}" />
                    <div class="col text-start">
                      <h5 class="mb-0">${repo.name}</h5>
                      <span class="opacity-500">${repo.description}</span>
                    </div>
                  </div>
                </button>`
              );
              $(`#btnSelectRepo${i}`).on("click", function(){
                selectRepo(repo);
              });
            });

            // Once we finish, we change form and stop the loading
            $("#loadingOverlay").addClass("d-none");
            $("#panelAuthorization").addClass("d-none");
            $("#panelRepoSelection").removeClass("d-none");
          }

          // If we catch an error, show it to the user
          // TODO: USE A MORE USER-FRIENDLY WAY TO SHOW THE ERROR
        } catch(e){
          $("#loadingOverlay").addClass("d-none");
          alert(e);
        }
      }

      async function selectRepo(repo){
        selectedRepo = repo;
        $("#loadingOverlay").removeClass("d-none");
        
        // Try to sync the repo and collect the database... we need it for the form
        var err = await syncRepoAndGetLatestDatabase();
        if(err != null){
          alert(err);

        } else{
          // We synced and got the db! Now we load the form
          $("#panelRepoSelection").addClass("d-none");
          $("#panelSubmissionDetails").removeClass("d-none");
        }

        $("#loadingOverlay").addClass("d-none");
      }

      async function syncRepoAndGetLatestDatabase(){
        const octokit = new Octokit({ auth: authToken });
        var error = null;
        database = [];
        

        // First, if the current repo is a fork, we try to sync to the latest commit
        if(selectedRepo.repoIsFork){
          var syncResponse = await octokit.request('POST /repos/{owner}/{repo}/merge-upstream', {
            owner: username,
            repo: selectedRepo.repoName,
            branch: selectedRepo.repoDefaultBranch
          }).catch((err) =>{
            error = `Couldn't sync fork to the latest commit: ${err}`;
          });
          if(syncResponse === undefined) return error;
        }
        
        
        // Collect the database json file
        var dbResponse = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
          owner: username,
          repo: selectedRepo.repoName,
          path: selectedRepo.database
        }).catch((err) => {
          error = `Couldn't get database file from the repo: ${err}`;
        });
        if(dbResponse === undefined) return error;

        // Load the database
        try{
          database = JSON.parse(atob(dbResponse.data.content));
          databaseSha = dbResponse.data.sha;

        } catch(e){
          alert(`Couldn't process database file, it could be corrupted: ${e}.\n\nThe process will continue, but the database will be remade.`);
          database = [];
          databaseSha = dbResponse.data.sha;
          return;
        }

        // Now that we are loaded, fill up the required forms
        var games = new Bloodhound({
          datumTokenizer: Bloodhound.tokenizers.whitespace,
          queryTokenizer: Bloodhound.tokenizers.whitespace,
          local: [...new Set(database.map((d) => d.game))],
        });
        $("#txtGameName").typeahead({
          hint: true,
          highlight: true, /* Enable substring highlighting */
          minLength: 1, /* Specify minimum characters required for showing suggestions */
        }, {
          name: 'games',
          source: games,
        });

        console.log("Database loaded!");
        console.log(database);
      }



      async function processFile(event) {
        // Read the file as a zip file
        // https://stuk.github.io/jszip/documentation/api_jszip.html
        try{
          $("#loadingOverlay").removeClass("d-none");
          var file = event.target.files[0];
          fileBase64 = (await toBase64(file)).split(",").pop();
          //console.log("File processed: " + fileBase64);

          // Open the file as a zip
          var zip = new JSZip();
          zip.loadAsync(file).then(function(zip) {

            // If it's not a valid file, we just stop the process here
            var ootrs = file.name.endsWith(".ootrs");
            if(!ootrs && !file.name.endsWith(".mmrs")) {
              alert("Not a valid z64 file (ootrs, mmrs)");
              $("#fileUpload").val("");
              $("#pInformationFromFile").addClass("d-none");
              return;
            }
            
            var usesCustomBank = false;
            var usesCustomSamples = false;

            // Run over each file and extract data
            zip.forEach(function(path, file) {

              // Read the OOTRS-only meta file
              if(ootrs && path.endsWith(".meta")){
                file.async("text").then(function(text) {
                  var lines = text.split("\n");
                  lines.forEach((line, i) => {
                    switch(i){
                      case 0: $("#lbInternalName").text(line); break;
                      case 2: $("#lbSequenceType").text(line); break;
                      case 3: $("#lbMusicGroups").text(line); break;
                    }
                  });
                });
              }

              // Read the MMRS-only categories file
              if(!ootrs && path == "categories.txt"){
                file.async("text").then(function(text) {
                  $("#lbCategories").text(text);
                });
              }

              // Check custom bank and samples
              if(path.endsWith(".zbank")) usesCustomBank = true;
              if(path.endsWith(".zsound")) usesCustomSamples = true;
            });

            // Load the info for both file types
            $("#lbFormat").text(ootrs ? "OOTRS" : "MMRS");
            $("#lbUsesCustomBank").text(usesCustomBank ? "Yes" : "No");
            $("#lbUsesCustomSamples").text(usesCustomSamples ? "Yes" : "No");

            // Toggle the info only for each file type
            $("#lbOOTRSOnlyInfo").toggleClass("d-none", !ootrs);
            $("#lbMMRSOnlyInfo").toggleClass("d-none", ootrs);

            // Show the information
            $("#pInformationFromFile").removeClass("d-none");

            // TODO: LOAD THE FORM IN THE CORRECT FORMAT (ootrs or mmrs)
            // If needed tho...

            $("#loadingOverlay").addClass("d-none");

            
          // File doesn't have the zip format
          }, function() {
            alert("Not a valid zip file");
            clearFileInput();
          });

        } catch(e){
          alert(`Couldn't process the file: ${e}`);
          clearFileInput();
        }
      }
      function clearFileInput(){
        fileBase64 = "";
        $("#pInformationFromFile").addClass("d-none");
        $("#fileUpload").val("");
        $("#loadingOverlay").addClass("d-none");
      }
      const toBase64 = file => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
      });



      function clearForm(){
        clearFileInput();
        $("#txtGameName").val("");
        $("#txtSongName").val("");
        $("#ddlSongType").val("bgm");
        $("#txtComposers").val("");
        $("#txtConverters").val("");
        $("#txtPreviewLink").val("");
        $("#txtNotes").val("");
        $("#mainForm").removeClass("was-validated");
      }


    
      async function submitForm(){

        // Check if the form is valid first
        var form = $("#mainForm")[0];
        var formIsValid = form.checkValidity();
        $("#mainForm").addClass("was-validated");
        if(!formIsValid) return;


        // Open octokit and trigger the overlay
        const octokit = new Octokit({ auth: authToken });
        $("#loadingOverlay").removeClass("d-none");


        // Get the latest database
        // Is this new one required?
        var syncError = await syncRepoAndGetLatestDatabase();
        if(syncError != null){
          alert(syncError);
          $("#loadingOverlay").addClass("d-none");
          return;
        }
        

        // Create the new entry
        var entry = {
          game: $("#txtGameName").val(),
          song: $("#txtSongName").val(),
          type: $("#ddlSongType").val(),
          composers: $("#txtComposers").val(),
          converters: $("#txtConverters").val(),
          preview: $("#txtPreviewLink").val(),

          categories: $("#lbFormat").text() == "OOTRS" ? $("#lbMusicGroups").text() : $("#lbCategories").text(),
          usesCustomBank: $("lbUsesCustomBank").text() == "Yes",
          usesCustomSamples: $("lbUsesCustomSamples").text() == "Yes",
          
          uuid: crypto.randomUUID(),
        };


        // Generate a local path for the entry
        var extension = $("#lbFormat").text().toLowerCase();
        var fileLocalPath = entry.game + "/" + entry.song + "." + extension;
        var finalPath = selectedRepo.binaries + fileLocalPath;
        entry.file = fileLocalPath;
        console.log(entry);


        // Add this entry to the json file
        database.push(entry);

        
        // Upload the file as a new commit
        var uploadFileResult = await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
          owner: username,
          repo: selectedRepo.repoName,
          path: finalPath,
          message: `Add new file ${fileLocalPath}`,
          content: fileBase64,
          
        }).catch((err) => {
          alert(`Couldn't upload the new file (${finalPath}) to the repo: ${err}`);
        });
        if(uploadFileResult === undefined) {
          $("#loadingOverlay").addClass("d-none");
          return;
        }
        console.log(uploadFileResult);


        // Update the database
        var updateDatabaseResult = await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
          owner: username,
          repo: selectedRepo.repoName,
          path: selectedRepo.database,
          message: `Add entry in database for file ${fileLocalPath}`,
          content: btoa(JSON.stringify(database, null, 2)), // <- We add spaces for readability for maintainers
          sha: databaseSha
          
        }).catch((err) => {
          alert(`Couldn't update database (${selectedRepo.database}) on the repo: ${err}`);
        });
        if(updateDatabaseResult === undefined) {
          $("#loadingOverlay").addClass("d-none");
          return;
        }
        console.log(updateDatabaseResult);


        // Do a pull request with the newly added files
        if(selectedRepo.repoIsFork){
          var additionalNotes = $("#txtNotes").val();
          var pullRequestResult = await octokit.request('POST /repos/{owner}/{repo}/pulls', {
            owner: selectedRepo.originalRepoOwner,
            repo: selectedRepo.repoName,
            title: `Add new song: ${entry.game} - ${entry.song}`,
            body: `Automatic PR created with Z64 Submission Form\n\nAdditional notes: ${additionalNotes}`,
            head: username + ":" + selectedRepo.repoDefaultBranch, // <-- We only do to the main branch... I could implement it for selected branches tho
            base: selectedRepo.repoDefaultBranch,

          }).catch((err) => {
            alert(`Couldn't create a pull request: ${err}`);
          });
          if(pullRequestResult === undefined) {
            $("#loadingOverlay").addClass("d-none");
            return;
          }
        }
        
        alert("Process completed!");
        clearForm();
        await syncRepoAndGetLatestDatabase();
        $("#loadingOverlay").addClass("d-none");
      }



      $(function(){
        // Submit mappings
        $("#btnLogin").on("click", userLogin);
        $("#btnSubmit").on("click", submitForm);

        // We don't want to trigger an actual submit, since we don't have any backend
        $("#mainForm").on("submit", function(e){
          e.preventDefault();
          e.stopPropagation();
        });
        
        // Form events
        $("#fileUpload").on("change", processFile);
        $("#txtGameName, #txtSongName").alphanum({
          allow: "!@#$%^&()+=[]\';,{}~`.- _", // We allow all character accepted as filenames
          //disallow: '\\/:*?"<>|',
        });
        

        $("#ddlSubmissionType").on("change", function(){
          $("#mainForm").toggleClass("d-none", this.value != "new")
          // TODO: ADD SELECT FOR CHOOSING THE SONG TO EDIT | this.value == "edit"
        });
      });
    </script>


    <div id="loadingOverlay" class="loading-overlay d-none">
      <i class="fa-solid fa-spinner fa-spin-pulse fa-3x"></i>
    </div>

    <nav class="navbar navbar-expand-lg bg-body-tertiary" style="padding-left: 8px; height: 46.5px;">
      <a class="navbar-brand text-secondary" style="width: 242px" href="#">
        Z64 Submission Form
      </a>
      
      <div class="col"></div>

      <div class="col-auto ml-auto d-none" id="niUsername">
        Logged as <b id="lbUsername">...</b>
      </div>

      <div class="col-auto px-2 d-none" id="niAvatar">
        <img id="imgAvatar" class="rounded-circle bg-white" width="30" height="30" src="" />
      </div>
    </nav>

    <div class="container">
      <div class="row justify-content-md-center pt-5 pb-5">

        <!-- AUTHORIZATION -->
        <div class="card rounded col p-3" style="max-width: 500px;" id="panelAuthorization">
          <h5>Authorization</h5>
          <p>This tools works by using the GitHub API to create commits and pull requests for you.</p>

          <div class="form-group mb-3">
            <label>GitHub authorization token:</label>
            <p class="hint">The token with access to the fork of the repository you are trying to send this file.</p>
            <input type="text" id="txtGithubAuthToken" class="form-control" placeholder="github_pat_xxxxx... or ghp_xxxxx..." />
          </div>

          <button type="button" class="btn btn-primary" id="btnLogin">Login</button>
        </div>


        <!-- SELECT A REPO -->
        <div class="card rounded col p-3 d-none" style="max-width: 500px;" id="panelRepoSelection">
          <h5>Select a repository</h5>
          <p>Select the repository you will be submitting a new music track.</p>
          <div class="container" id="containerRepo">
          </div>
        </div>


        <!-- SUBMISSION DETAILS -->
        <div class="card rounded col p-3 g-3 d-none" style="max-width: 500px;" id="panelSubmissionDetails">
          <h5>Submission details</h5>

          <div class="form-group mb-3">
            <label>Submission type:</label>
            <select id="ddlSubmissionType" class="form-select">
              <option value="">Select an option...</option>
              <option value="new">Upload a new song</option>
              <option value="edit">Modify/update existing song</option>
            </select>
          </div>

          <!--TODO: Add typeahead for choosing the existing track on edit mode-->

          <form id="mainForm" class="d-none needs-validation">

            <div class="form-group mb-3">
              <label>File:</label>
              <p class="hint">The z64 song file you are uploading (ootrs, mmrs). If you are only editing the metadata of an existing track, you can leave this input empty to not make any changes to the already uploaded file.</p>
              <input id="fileUpload" type="file" class="form-control" accept=".ootrs,.mmrs" required/>
              <p class="opacity-600 mb-0 d-none" id="pInformationFromFile">
                Information extracted from the file:<br>
                <b>• Format:</b> <span id="lbFormat">...</span><br>
                <span id="lbOOTRSOnlyInfo">
                  <b>• Internal name:</b> <span id="lbInternalName">...</span><br>
                  <b>• Sequence type:</b> <span id="lbSequenceType">...</span><br>
                  <b>• Music groups:</b> <span id="lbMusicGroups">...</span><br>
                </span>
                <span id="lbMMRSOnlyInfo">
                  <b>• Categories:</b> <span id="lbCategories">...</span><br>
                </span>
                <b>• Uses custom bank:</b> <span id="lbUsesCustomBank">...</span><br>
                <b>• Uses custom samples:</b> <span id="lbUsesCustomSamples">...</span>
              </p>
              <div class="invalid-feedback">
                A valid file is needed for upload.
              </div>
            </div>
  
            <hr>
  
            <div class="form-group mb-3">
              <label>Game name:</label>
              <p class="hint">The name of the game your song comes from.</p>
              <input id="txtGameName" type="text" class="form-control" placeholder="E.g.: Super Mario Galaxy" required />
              <div class="invalid-feedback">
                Please insert a game name.
              </div>
            </div>
  
            <!--TODO: Make sure in new mode, we are not using an existing track's name-->
            <div class="form-group mb-3">
              <label>Song name:</label>
              <p class="hint">The actual name of the song.</p>
              <input id="txtSongName" type="text" class="form-control" placeholder="E.g.: Rosalina's Observatory" required />
              <div class="invalid-feedback">
                Please insert a name for the song.
              </div>
            </div>
  
            <div class="form-group mb-3">
              <label>Song type:</label>
              <p class="hint">
                <b>• Background Music (BGM):</b> looping track, used as background music.<br>
                <b>• Fanfare:</b> non looping track, used for events (e.g. when you find items).
              </p>
              <select id="ddlSongType" class="form-select">
                <option value="bgm">Background Music (BGM)</option>
                <option value="fanfare">Fanfare</option>
              </select>
            </div>
  
            <hr>
  
            <div class="form-group mb-3">
              <label>Composer(s):</label>
              <p class="hint">A list of the names of the original composers of this song.<br>
              List multiple composer separated by comma.</p>
              <input id="txtComposers" type="text" class="form-control" placeholder="E.g.: Koji Kondo, Kazumi Totaka" />
            </div>
  
            <div class="form-group mb-3">
              <label>Converter(s):</label>
              <p class="hint">A list of the names of ones who converted this song to the Zelda 64 format.</p>
              <input id="txtConverters" type="text" class="form-control" placeholder="E.g.: Tolin, Owl is not a Cat" />
            </div>
  
            <hr>
  
            <div class="form-group mb-3">
              <label>Preview link:</label>
              <p class="hint">
                Link to a preview of this song. Can it be on two formats:<br>
                <b>• YouTube link:</b> link to a video uploaded to YouTube of your version of the song.<br>
                <b>• Direct sound file link:</b> direct link to a sound file (.mp3, .wav, etc) uploaded on a public site (Mega, Discord, GitHub, etc).
              </p>
              <input id="txtPreviewLink" type="text" class="form-control" required />
              <div class="invalid-feedback">
                A preview link is required.
              </div>
            </div>
  
            <div class="form-group mb-3">
              <label>Notes:</label>
              <p class="hint">
                Additional notes for the people handling your submission.
              </p>
              <input id="txtNotes" type="text" class="form-control" />
            </div>
  
            <button id="btnSubmit" type="submit" class="btn btn-primary w-100">Submit</button>
          </form>
          
        </div>
      </div>
    </div>
  </body>
</html>